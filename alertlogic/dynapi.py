# -*- coding: utf-8 -*-
"""
    alertlogic.dynapi
    ~~~~~~~~~~~~~~
    Implements dynamic apis based on metaprogramming, apidoc json data and the requests library
"""

import core

import requests
import json
import logging

log = logging.getLogger(__name__)

class DynAPIException(core.AlertlogicException):
    def __init__(self, message):
        super(DynAPIException, self).__init__(core.Constants.CONTACT_MESSAGE+"dynapi error: "+message)

class InvalidEndpointDefinition(DynAPIException): pass
class InvalidEndpointCall(DynAPIException): pass

class Services():
    """Creates and register one Service for each apidoc json file found in API_SERVICES
    these json files are published along the content of the html api documentation generated by apidoc
    more info: http://apidocjs.com
    """
    def __init__(self):
        for service_name in core.Constants.API_SERVICES:
            filename = core.Constants.API_DATA_DIR+"/"+service_name+".json"
            service = self.parse_apidoc_file(filename)
            self.__dict__[service_name] = service
    
    def parse_apidoc_file(self, filename):
        """generates a Service() object by parsing an apidoc json file
        """
        with open(filename) as file:
            api_data = json.load(file)
            return self.parse_apidoc(api_data)
    
    def parse_apidoc(self, api_data):
        """Parses apidoc data into a Service() object
        """
        service = Service()
        for api_data_endpoint in api_data:
            try:
                name = api_data_endpoint["name"].lower()
                operation = api_data_endpoint["type"].upper()
                url = api_data_endpoint["url"]
                service.add_endpoint(name, operation, url)
            except (KeyError, InvalidEndpointDefinition) as e:
                log.debug("unable to parse apidoc endpoint: {}".format(e))
                pass
        return service
    
    def set_session(self, session):
        """this function makes it easier to call set_session on all the underlying services
        """
        for service_name in core.Constants.API_SERVICES:
            service = self.__dict__[service_name]
            service.set_session(session)

class Service():
    """Stores a set of Endpoint()s and allows to call them dynamically as functions
    by using metaprogramming
    """
    def __init__(self):
        self._endpoints = {}
        self._session = None
    
    def add_endpoint(self, name, operation, url):
        """Creates and store a Endpoint()
        """
        endpoint = Endpoint(name, operation, url)
        self._endpoints[endpoint.name] = endpoint
    
    def set_session(self, session):
        self._session = session
    
    def __getattr__(self, name):
        """returns an unbound function *handler* capable of calling a Endpoint()
        in python this function is called everytime an object's property is not found
        this is what allows us to dynamically add functions to an existing object
        """
        def handler(*args, **kwargs):
            if name in self._endpoints:
                # json argument are passed separately
                json = kwargs.pop("json", None)
                # if account_id is not an argument then use the one provided by session
                if "account_id" not in kwargs:
                    kwargs["account_id"] = self._session.account
                return self._endpoints[name].call(self._session, kwargs, json=json)
            else:
                # you've tried to call an undefined endpoint
                raise InvalidEndpointCall("endpoint not found: {}".format(name))
        return handler

class Endpoint():
    """Represents 1 service endpoint, requirements:
    * name
    * an operation ("POST", "GET", etc)
    * url, the format should be the one used in apidoc, this means required url arguments
    start with ":" e.g:
    /scheduler/v1/:account_id/:environment_id/scan?asset=:asset_key
    to call the above endpoint you'll need to provide account_id, environment_id and asset_key
    """
    def __init__(self, name, operation, url):
        self.name = name
        self.url = url
        self.operation = operation
        # verifies that the given operation is correct
        if self.operation not in ["GET", "POST", "DELETE", "PUT", "HEAD"]:
            raise InvalidEndpointDefinition("invalid operation: {}".format(self.operation))
    
    def parse_url(self, url_args):
        """Parses an endpoint's url by replacing the parts that start with ":" with the values of *url_args*
        e.g:
            endpoint.url = "/scheduler/v1/:account_id/:environment_id/scan?asset=:asset_key"
            endpoint.parse_url({"account_id": "2",
                                "environment_id": "BA395435-551B-4250-B52E-71FCCFF73124"
                                "asset_key": "/aws/us-east-1/host/i-023c7629"})
            "/scheduler/v1/12345678/BA395435-551B-4250-B52E-71FCCFF73124/scan?asset=/aws/us-east-1/host/i-023c7629"
        """
        parts = [part for part in self.url.lower().split("/") if len(part) > 0]
        parsed_url = ""
        for part in parts:
            if part.startswith(":"):
                required_arg = part[1:] # removes ":" at the beginning of the string
                if required_arg in url_args:
                    parsed_url += "/"+url_args[required_arg]
                else:
                    raise InvalidEndpointCall("missing required url argument {}".format(required_arg))
            else:
                parsed_url += "/"+part
        return parsed_url
    
    def call(self, session, url_args, json=None):
        """makes the http call by generating the url (see parse_url()), uses session as auth plugin
        """
        parsed_url = session.api_url + self.parse_url(url_args)
        log.debug("calling: {} {}".format(self.operation, parsed_url))
        return requests.request(self.operation, parsed_url, json=json, auth=session)        
